// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package pg

import (
	"context"
)

const createTransfer = `-- name: CreateTransfer :one
INSERT INTO transfers (transaction, sender, receiver, token_id, read)
VALUES ($1, $2, $3, $4, $5)
RETURNING transaction, sender, receiver, token_id, read
`

type CreateTransferParams struct {
	Transaction string
	Sender      string
	Receiver    string
	TokenID     int32
	Read        bool
}

func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (Transfer, error) {
	row := q.db.QueryRowContext(ctx, createTransfer,
		arg.Transaction,
		arg.Sender,
		arg.Receiver,
		arg.TokenID,
		arg.Read,
	)
	var i Transfer
	err := row.Scan(
		&i.Transaction,
		&i.Sender,
		&i.Receiver,
		&i.TokenID,
		&i.Read,
	)
	return i, err
}

const listTransfersByReceiver = `-- name: ListTransfersByReceiver :many
SELECT transaction, sender, receiver, token_id, read FROM transfers
WHERE receiver = $1
`

func (q *Queries) ListTransfersByReceiver(ctx context.Context, receiver string) ([]Transfer, error) {
	rows, err := q.db.QueryContext(ctx, listTransfersByReceiver, receiver)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.Transaction,
			&i.Sender,
			&i.Receiver,
			&i.TokenID,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransfersBySender = `-- name: ListTransfersBySender :many
SELECT transaction, sender, receiver, token_id, read FROM transfers
WHERE sender = $1
`

func (q *Queries) ListTransfersBySender(ctx context.Context, sender string) ([]Transfer, error) {
	rows, err := q.db.QueryContext(ctx, listTransfersBySender, sender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.Transaction,
			&i.Sender,
			&i.Receiver,
			&i.TokenID,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransfersByTokenID = `-- name: ListTransfersByTokenID :many
SELECT transaction, sender, receiver, token_id, read FROM transfers
WHERE token_id = $1
`

func (q *Queries) ListTransfersByTokenID(ctx context.Context, tokenID int32) ([]Transfer, error) {
	rows, err := q.db.QueryContext(ctx, listTransfersByTokenID, tokenID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.Transaction,
			&i.Sender,
			&i.Receiver,
			&i.TokenID,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransfersByTransaction = `-- name: ListTransfersByTransaction :many
SELECT transaction, sender, receiver, token_id, read FROM transfers
WHERE transaction = $1
`

func (q *Queries) ListTransfersByTransaction(ctx context.Context, transaction string) ([]Transfer, error) {
	rows, err := q.db.QueryContext(ctx, listTransfersByTransaction, transaction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.Transaction,
			&i.Sender,
			&i.Receiver,
			&i.TokenID,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreadTransfers = `-- name: ListUnreadTransfers :many
SELECT transaction, sender, receiver, token_id, read FROM transfers
Where read = FALSE
`

func (q *Queries) ListUnreadTransfers(ctx context.Context) ([]Transfer, error) {
	rows, err := q.db.QueryContext(ctx, listUnreadTransfers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transfer
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.Transaction,
			&i.Sender,
			&i.Receiver,
			&i.TokenID,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readTransfer = `-- name: ReadTransfer :one
UPDATE transfers
SET read = TRUE
WHERE transaction = $1
RETURNING transaction, sender, receiver, token_id, read
`

func (q *Queries) ReadTransfer(ctx context.Context, transaction string) (Transfer, error) {
	row := q.db.QueryRowContext(ctx, readTransfer, transaction)
	var i Transfer
	err := row.Scan(
		&i.Transaction,
		&i.Sender,
		&i.Receiver,
		&i.TokenID,
		&i.Read,
	)
	return i, err
}
